<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TSP Visual Solver - Sonar & Moore Curve Algorithms</title>
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="src/ui/styles.css" />
  </head>
  <body>
    <div id="root"></div>

    <!-- Load algorithm modules -->
    <script type="text/babel" data-type="module">
      // ============================================================
      // ALGORITHMS - Utility Functions
      // ============================================================

      const calculateMooreGridSize = (gridSize) => {
        const order = Math.max(1, Math.min(4, Math.floor(Math.log2(gridSize))));
        return Math.pow(2, order + 1);
      };

      const generateRandomPoints = (mooreGridSize, numPoints) => {
        const points = [];
        const usedPositions = new Set();
        const maxPoints = Math.min(
          numPoints,
          (mooreGridSize + 1) * (mooreGridSize + 1)
        );

        while (points.length < maxPoints) {
          const x = Math.floor(Math.random() * (mooreGridSize + 1));
          const y = Math.floor(Math.random() * (mooreGridSize + 1));
          const key = `${x},${y}`;

          if (!usedPositions.has(key)) {
            usedPositions.add(key);
            points.push({ x, y, id: points.length });
          }
        }
        return points;
      };

      const distance = (p1, p2) => Math.hypot(p2.x - p1.x, p2.y - p1.y);

      const calculateTotalDistance = (tour, points) => {
        if (tour.length < 2) return 0;
        let total = 0;
        for (let i = 0; i < tour.length - 1; i++) {
          total += distance(points[tour[i]], points[tour[i + 1]]);
        }
        total += distance(points[tour[tour.length - 1]], points[tour[0]]);
        return total;
      };

      // ============================================================
      // ALGORITHMS - Sonar (Radial Sweep)
      // ============================================================

      const sonarAlgorithmSteps = (points) => {
        if (points.length === 0) return [];

        const cx = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const cy = points.reduce((sum, p) => sum + p.y, 0) / points.length;
        const startAngle = Math.PI / 2;

        const pointsWithAngles = points.map((p, idx) => {
          const rawAngle = Math.atan2(p.y - cy, p.x - cx);
          let normalizedAngle = rawAngle - startAngle;
          if (normalizedAngle < 0) {
            normalizedAngle += 2 * Math.PI;
          }
          return { ...p, idx, angle: rawAngle, sortAngle: normalizedAngle };
        });

        pointsWithAngles.sort((a, b) => a.sortAngle - b.sortAngle);

        const steps = [];
        const tour = [];

        for (let i = 0; i < pointsWithAngles.length; i++) {
          const currentAngle = pointsWithAngles[i].angle;
          tour.push(pointsWithAngles[i].idx);

          steps.push({
            type: 'sweep',
            angle: currentAngle,
            tour: [...tour],
            description: `Sweep angle: ${(((currentAngle * 180) / Math.PI + 360) % 360).toFixed(1)}°, found point ${pointsWithAngles[i].idx}`,
            centroid: { x: cx, y: cy },
          });
        }

        return steps;
      };

      // ============================================================
      // ALGORITHMS - Moore Curve
      // ============================================================

      const generateMooreCurve = (order) => {
        let sequence = 'LFL+F+LFL';

        for (let i = 0; i < order; i++) {
          let newSequence = '';
          for (const char of sequence) {
            if (char === 'L') {
              newSequence += '-RF+LFL+FR-';
            } else if (char === 'R') {
              newSequence += '+LF-RFR-FL+';
            } else {
              newSequence += char;
            }
          }
          sequence = newSequence;
        }

        return sequence;
      };

      const mooreCurveToPoints = (sequence, mooreGridSize) => {
        const stepSize = 1;
        const curvePoints = [];
        let x = 0;
        let y = 0;
        let direction = 0;

        curvePoints.push({ x, y });

        for (const char of sequence) {
          if (char === 'F') {
            if (direction === 0) y -= stepSize;
            else if (direction === 1) x += stepSize;
            else if (direction === 2) y += stepSize;
            else if (direction === 3) x -= stepSize;
            curvePoints.push({ x, y });
          } else if (char === '+') {
            direction = (direction + 1) % 4;
          } else if (char === '-') {
            direction = (direction + 3) % 4;
          }
        }

        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        for (const p of curvePoints) {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        }

        const curveWidth = maxX - minX;
        const curveHeight = maxY - minY;

        const normalizedPoints = curvePoints.map((p) => ({
          x: Math.round(((p.x - minX) / curveWidth) * mooreGridSize),
          y: Math.round(((p.y - minY) / curveHeight) * mooreGridSize),
        }));

        return normalizedPoints;
      };

      const mooreAlgorithmSteps = (points, mooreGridSize) => {
        if (points.length === 0) return [];

        const order = Math.max(1, Math.round(Math.log2(mooreGridSize)) - 1);
        const curveSequence = generateMooreCurve(order);
        const curvePoints = mooreCurveToPoints(curveSequence, mooreGridSize);
        const totalCurveLength = curvePoints.length;

        const pointsWithCurvePos = points.map((p, idx) => {
          let minDist = Infinity;
          let curvePos = 0;

          for (let i = 0; i < curvePoints.length; i++) {
            const d = distance(p, curvePoints[i]);
            if (d < minDist) {
              minDist = d;
              curvePos = i;
            }
          }

          return { ...p, idx, curvePos };
        });

        pointsWithCurvePos.sort((a, b) => a.curvePos - b.curvePos);

        const steps = [];
        const tour = [];

        steps.push({
          type: 'curve',
          curvePoints,
          mooreGridSize,
          curveProgress: 0,
          tour: [],
          description: `Moore curve generated (order ${order}, ${mooreGridSize}×${mooreGridSize} grid)`,
        });

        for (let i = 0; i < pointsWithCurvePos.length; i++) {
          tour.push(pointsWithCurvePos[i].idx);
          const curveProgress = (
            (pointsWithCurvePos[i].curvePos / (totalCurveLength - 1)) *
            100
          ).toFixed(1);

          steps.push({
            type: 'visit',
            curvePoints,
            mooreGridSize,
            curvePosition: pointsWithCurvePos[i].curvePos,
            curveProgress: parseFloat(curveProgress),
            tour: [...tour],
            description: `Curve progress: ${curveProgress}%, visiting point ${pointsWithCurvePos[i].idx}`,
          });
        }

        return steps;
      };

      // ============================================================
      // ALGORITHMS - Optimizations
      // ============================================================

      const sonarOptimizationSteps = (points, initialTour) => {
        if (initialTour.length < 4) return [];

        const steps = [];
        const tour = [...initialTour];
        let improved = true;
        let iteration = 0;
        const maxIterations = 100;

        while (improved && iteration < maxIterations) {
          improved = false;
          iteration++;

          for (let i = 0; i < tour.length - 2; i++) {
            const p1 = points[tour[i]];
            const p2 = points[tour[i + 1]];
            const p3 = points[tour[(i + 2) % tour.length]];
            const p4 = points[tour[(i + 3) % tour.length]];

            const currentDist = distance(p1, p2) + distance(p3, p4);
            const newDist = distance(p1, p3) + distance(p2, p4);

            if (newDist < currentDist - 0.001) {
              const idx2 = (i + 1) % tour.length;
              const idx3 = (i + 2) % tour.length;
              [tour[idx2], tour[idx3]] = [tour[idx3], tour[idx2]];

              steps.push({
                type: 'optimize',
                tour: [...tour],
                swapped: [tour[idx2], tour[idx3]],
                improvement: currentDist - newDist,
                description: `Zigzag optimization: swapped points, saved ${(currentDist - newDist).toFixed(2)} units`,
              });

              improved = true;
            }
          }
        }

        return steps;
      };

      const mooreOptimizationSteps = (points, initialTour) => {
        if (initialTour.length < 4) return [];

        const steps = [];
        const tour = [...initialTour];
        let improved = true;
        let iteration = 0;
        const maxIterations = 50;

        while (improved && iteration < maxIterations) {
          improved = false;
          iteration++;

          for (let i = 0; i < tour.length - 1; i++) {
            for (let j = i + 2; j < tour.length; j++) {
              if (i === 0 && j === tour.length - 1) continue;

              const a = points[tour[i]];
              const b = points[tour[i + 1]];
              const c = points[tour[j]];
              const d = points[tour[(j + 1) % tour.length]];

              const currentDist = distance(a, b) + distance(c, d);
              const newDist = distance(a, c) + distance(b, d);

              if (newDist < currentDist - 0.001) {
                const segment = tour.slice(i + 1, j + 1).reverse();
                tour.splice(i + 1, j - i, ...segment);

                steps.push({
                  type: 'optimize',
                  tour: [...tour],
                  reversed: [i + 1, j],
                  improvement: currentDist - newDist,
                  description: `2-opt: reversed segment [${i + 1}, ${j}], saved ${(currentDist - newDist).toFixed(2)} units`,
                });

                improved = true;
                break;
              }
            }
            if (improved) break;
          }
        }

        return steps;
      };

      // ============================================================
      // UI COMPONENTS
      // ============================================================

      const { useState, useEffect, useRef, useCallback } = React;

      // TSPVisualization Component
      const TSPVisualization = ({
        points,
        steps,
        currentStep,
        algorithm,
        mooreGridSize,
        showOptimization,
      }) => {
        const containerRef = useRef(null);
        const [svgSize, setSvgSize] = useState(400);
        const padding = 20;

        useEffect(() => {
          const updateSize = () => {
            if (containerRef.current) {
              const containerWidth = containerRef.current.clientWidth;
              const newSize = Math.min(400, Math.max(280, containerWidth - 32));
              setSvgSize(newSize);
            }
          };

          updateSize();
          window.addEventListener('resize', updateSize);
          return () => window.removeEventListener('resize', updateSize);
        }, []);

        const size = svgSize;
        const step =
          currentStep >= 0 && currentStep < steps.length
            ? steps[currentStep]
            : null;
        const displayGridSize = mooreGridSize;
        const scale = (size - 2 * padding) / displayGridSize;

        const toSvgCoords = (p) => ({
          x: padding + p.x * scale,
          y: padding + p.y * scale,
        });

        const gridLines = [];
        for (let i = 0; i <= displayGridSize; i++) {
          const pos = padding + i * scale;
          gridLines.push(
            <line
              key={`v-${i}`}
              x1={pos}
              y1={padding}
              x2={pos}
              y2={size - padding}
              stroke="#e9ecef"
              strokeWidth="1"
            />
          );
          gridLines.push(
            <line
              key={`h-${i}`}
              x1={padding}
              y1={pos}
              x2={size - padding}
              y2={pos}
              stroke="#e9ecef"
              strokeWidth="1"
            />
          );
        }

        let mooreCurvePath = null;
        let mooreCurveGrayPath = null;
        if (
          algorithm === 'moore' &&
          step?.curvePoints &&
          step.curvePoints.length > 0
        ) {
          const curvePosition =
            step.curvePosition !== undefined ? step.curvePosition : 0;
          const visitedPoints = step.curvePoints.slice(0, curvePosition + 1);
          const unvisitedPoints = step.curvePoints.slice(curvePosition);

          if (unvisitedPoints.length > 1) {
            const grayPathData = unvisitedPoints
              .map((p, i) => {
                const coords = toSvgCoords(p);
                return i === 0
                  ? `M ${coords.x} ${coords.y}`
                  : `L ${coords.x} ${coords.y}`;
              })
              .join(' ');
            mooreCurveGrayPath = (
              <path
                d={grayPathData}
                fill="none"
                stroke="rgba(156, 163, 175, 0.5)"
                strokeWidth="3"
                strokeLinecap="square"
                strokeLinejoin="miter"
              />
            );
          }

          if (visitedPoints.length > 0) {
            const greenPathData = visitedPoints
              .map((p, i) => {
                const coords = toSvgCoords(p);
                return i === 0
                  ? `M ${coords.x} ${coords.y}`
                  : `L ${coords.x} ${coords.y}`;
              })
              .join(' ');
            mooreCurvePath = (
              <path
                d={greenPathData}
                fill="none"
                stroke="rgba(34, 197, 94, 0.6)"
                strokeWidth="3"
                strokeLinecap="square"
                strokeLinejoin="miter"
              />
            );
          }
        }

        let sweepLine = null;
        let centroidCircle = null;
        if (algorithm === 'sonar' && step?.type === 'sweep' && step?.centroid) {
          const center = toSvgCoords(step.centroid);
          const lineLength = size;
          sweepLine = (
            <line
              x1={center.x}
              y1={center.y}
              x2={center.x + lineLength * Math.cos(step.angle)}
              y2={center.y + lineLength * Math.sin(step.angle)}
              stroke="rgba(13, 110, 253, 0.3)"
              strokeWidth="2"
            />
          );
          centroidCircle = (
            <circle cx={center.x} cy={center.y} r="4" fill="#0d6efd" />
          );
        }

        let tourPath = null;
        if (step?.tour && step.tour.length > 1) {
          const isOptimization = step.type === 'optimize' || showOptimization;
          const tourPoints = step.tour.map((idx) => toSvgCoords(points[idx]));
          let pathData = tourPoints
            .map((p, i) => (i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`))
            .join(' ');
          if (step.tour.length === points.length) {
            pathData += ' Z';
          }
          tourPath = (
            <path
              d={pathData}
              fill="none"
              stroke={isOptimization ? '#198754' : '#0d6efd'}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          );
        }

        const pointCircles = points.map((point, idx) => {
          const p = toSvgCoords(point);
          const isInTour = step?.tour?.includes(idx);
          const isLastAdded =
            step?.tour && step.tour[step.tour.length - 1] === idx;

          let fill = '#6c757d';
          if (isLastAdded) {
            fill = '#dc3545';
          } else if (isInTour) {
            fill = '#0d6efd';
          }

          return (
            <circle
              key={`point-${idx}`}
              cx={p.x}
              cy={p.y}
              r={isLastAdded ? 6 : 4}
              fill={fill}
            />
          );
        });

        return (
          <div
            ref={containerRef}
            style={{ width: '100%', display: 'flex', justifyContent: 'center' }}
          >
            <svg
              width={size}
              height={size}
              viewBox={`0 0 ${size} ${size}`}
              style={{
                border: '1px solid #dee2e6',
                borderRadius: '4px',
                background: '#ffffff',
              }}
            >
              <g>{gridLines}</g>
              {mooreCurveGrayPath}
              {mooreCurvePath}
              {sweepLine}
              {centroidCircle}
              {tourPath}
              <g>{pointCircles}</g>
            </svg>
          </div>
        );
      };

      const TSPCanvas = TSPVisualization;

      // Main App Component
      const App = () => {
        const [gridSize, setGridSize] = useState(10);
        const [numPoints, setNumPoints] = useState(15);
        const [points, setPoints] = useState([]);
        const [speed, setSpeed] = useState(500);
        const [isRunning, setIsRunning] = useState(false);
        const [showOptimization, setShowOptimization] = useState(false);

        const mooreGridSize = calculateMooreGridSize(gridSize);

        const [sonarSteps, setSonarSteps] = useState([]);
        const [sonarOptSteps, setSonarOptSteps] = useState([]);
        const [sonarCurrentStep, setSonarCurrentStep] = useState(-1);

        const [mooreSteps, setMooreSteps] = useState([]);
        const [mooreOptSteps, setMooreOptSteps] = useState([]);
        const [mooreCurrentStep, setMooreCurrentStep] = useState(-1);

        const animationRef = useRef(null);

        const generatePoints = useCallback(() => {
          const newPoints = generateRandomPoints(mooreGridSize, numPoints);
          setPoints(newPoints);
          setSonarSteps([]);
          setSonarOptSteps([]);
          setSonarCurrentStep(-1);
          setMooreSteps([]);
          setMooreOptSteps([]);
          setMooreCurrentStep(-1);
          setIsRunning(false);
          setShowOptimization(false);
        }, [mooreGridSize, numPoints]);

        useEffect(() => {
          generatePoints();
        }, []);

        const startSolution = useCallback(() => {
          if (points.length === 0) return;

          const newSonarSteps = sonarAlgorithmSteps(points);
          const newMooreSteps = mooreAlgorithmSteps(points, mooreGridSize);

          setSonarSteps(newSonarSteps);
          setMooreSteps(newMooreSteps);
          setSonarCurrentStep(0);
          setMooreCurrentStep(0);
          setShowOptimization(false);
          setIsRunning(true);
        }, [points, mooreGridSize]);

        const stopAnimation = useCallback(() => {
          setIsRunning(false);
          if (animationRef.current) {
            clearTimeout(animationRef.current);
          }
        }, []);

        const startOptimization = useCallback(() => {
          if (sonarSteps.length === 0 || mooreSteps.length === 0) return;

          const sonarTour = sonarSteps[sonarSteps.length - 1]?.tour || [];
          const mooreTour = mooreSteps[mooreSteps.length - 1]?.tour || [];

          const newSonarOptSteps = sonarOptimizationSteps(points, sonarTour);
          const newMooreOptSteps = mooreOptimizationSteps(points, mooreTour);

          setSonarOptSteps(newSonarOptSteps);
          setMooreOptSteps(newMooreOptSteps);
          setSonarCurrentStep(0);
          setMooreCurrentStep(0);
          setShowOptimization(true);
          setIsRunning(true);
        }, [points, sonarSteps, mooreSteps]);

        useEffect(() => {
          if (!isRunning) return;

          const currentSonarSteps = showOptimization
            ? sonarOptSteps
            : sonarSteps;
          const currentMooreSteps = showOptimization
            ? mooreOptSteps
            : mooreSteps;

          const sonarDone = sonarCurrentStep >= currentSonarSteps.length - 1;
          const mooreDone = mooreCurrentStep >= currentMooreSteps.length - 1;

          if (sonarDone && mooreDone) {
            setIsRunning(false);
            return;
          }

          animationRef.current = setTimeout(() => {
            if (!sonarDone) {
              setSonarCurrentStep((prev) =>
                Math.min(prev + 1, currentSonarSteps.length - 1)
              );
            }
            if (!mooreDone) {
              setMooreCurrentStep((prev) =>
                Math.min(prev + 1, currentMooreSteps.length - 1)
              );
            }
          }, speed);

          return () => {
            if (animationRef.current) {
              clearTimeout(animationRef.current);
            }
          };
        }, [
          isRunning,
          sonarCurrentStep,
          mooreCurrentStep,
          speed,
          showOptimization,
          sonarSteps,
          mooreSteps,
          sonarOptSteps,
          mooreOptSteps,
        ]);

        const getSonarStep = () => {
          const steps = showOptimization ? sonarOptSteps : sonarSteps;
          return steps[sonarCurrentStep];
        };

        const getMooreStep = () => {
          const steps = showOptimization ? mooreOptSteps : mooreSteps;
          return steps[mooreCurrentStep];
        };

        const calculateSonarDistance = () => {
          const step = getSonarStep();
          if (!step?.tour || step.tour.length < 2) return 0;
          return calculateTotalDistance(step.tour, points);
        };

        const calculateMooreDistance = () => {
          const step = getMooreStep();
          if (!step?.tour || step.tour.length < 2) return 0;
          return calculateTotalDistance(step.tour, points);
        };

        const canOptimize =
          sonarSteps.length > 0 &&
          mooreSteps.length > 0 &&
          !isRunning &&
          !showOptimization &&
          sonarCurrentStep === sonarSteps.length - 1;

        return (
          <div className="app">
            <h1>TSP Visual Solver</h1>

            <div className="controls">
              <div className="control-group">
                <label>Grid Size (N)</label>
                <input
                  type="number"
                  min="5"
                  max="50"
                  value={gridSize}
                  onChange={(e) =>
                    setGridSize(
                      Math.max(5, Math.min(50, parseInt(e.target.value) || 5))
                    )
                  }
                  disabled={isRunning}
                />
              </div>

              <div className="control-group">
                <label>Points (M)</label>
                <input
                  type="number"
                  min="3"
                  max={(mooreGridSize + 1) * (mooreGridSize + 1)}
                  value={numPoints}
                  onChange={(e) =>
                    setNumPoints(Math.max(3, parseInt(e.target.value) || 3))
                  }
                  disabled={isRunning}
                />
              </div>

              <div className="control-group">
                <label>Animation Speed</label>
                <div className="speed-control">
                  <span>Fast</span>
                  <input
                    type="range"
                    min="50"
                    max="1000"
                    value={speed}
                    onChange={(e) => setSpeed(parseInt(e.target.value))}
                  />
                  <span>Slow</span>
                </div>
              </div>

              <div className="buttons">
                <button
                  className="btn-outline"
                  onClick={generatePoints}
                  disabled={isRunning}
                >
                  New Points
                </button>

                {!isRunning ? (
                  <>
                    <button
                      className="btn-primary"
                      onClick={startSolution}
                      disabled={points.length === 0}
                    >
                      Start
                    </button>

                    {canOptimize && (
                      <button
                        className="btn-secondary"
                        onClick={startOptimization}
                      >
                        Optimize
                      </button>
                    )}
                  </>
                ) : (
                  <button className="btn-secondary" onClick={stopAnimation}>
                    Stop
                  </button>
                )}
              </div>
            </div>

            <div className="visualization-container">
              <div className="visualization">
                <div className="visualization-header">
                  <h2>Sonar Visit Algorithm</h2>
                  <span className="visualization-stats">
                    Distance: {calculateSonarDistance().toFixed(2)}
                  </span>
                </div>
                <div className="algorithm-aliases">
                  Also known as: Radial Sweep, Angular Sort, Polar Angle Sort,
                  Centroid-based Ordering
                </div>
                <div className="canvas-wrapper">
                  <TSPCanvas
                    points={points}
                    steps={showOptimization ? sonarOptSteps : sonarSteps}
                    currentStep={sonarCurrentStep}
                    algorithm="sonar"
                    mooreGridSize={mooreGridSize}
                    showOptimization={showOptimization}
                  />
                </div>
                <div className="step-info">
                  {getSonarStep()?.description || 'Click Start to begin'}
                </div>
                <div className="legend">
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#6c757d' }}
                    ></div>
                    <span>Unvisited</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#0d6efd' }}
                    ></div>
                    <span>In Tour</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#dc3545' }}
                    ></div>
                    <span>Current</span>
                  </div>
                  {showOptimization && (
                    <div className="legend-item">
                      <div
                        className="legend-color"
                        style={{ background: '#198754' }}
                      ></div>
                      <span>Optimized</span>
                    </div>
                  )}
                </div>
              </div>

              <div className="visualization">
                <div className="visualization-header">
                  <h2>Moore Curve Algorithm</h2>
                  <span className="visualization-stats">
                    Distance: {calculateMooreDistance().toFixed(2)}
                  </span>
                </div>
                <div className="algorithm-aliases">
                  Also known as: Space-Filling Curve, Hilbert Curve Variant,
                  Fractal Ordering
                </div>
                <div className="canvas-wrapper">
                  <TSPCanvas
                    points={points}
                    steps={showOptimization ? mooreOptSteps : mooreSteps}
                    currentStep={mooreCurrentStep}
                    algorithm="moore"
                    mooreGridSize={mooreGridSize}
                    showOptimization={showOptimization}
                  />
                </div>
                <div className="step-info">
                  {getMooreStep()?.description || 'Click Start to begin'}
                </div>
                <div className="legend">
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: 'rgba(34, 197, 94, 0.6)' }}
                    ></div>
                    <span>Visited Curve</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: 'rgba(156, 163, 175, 0.5)' }}
                    ></div>
                    <span>Unvisited Curve</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#0d6efd' }}
                    ></div>
                    <span>Tour Path</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#dc3545' }}
                    ></div>
                    <span>Current</span>
                  </div>
                  {showOptimization && (
                    <div className="legend-item">
                      <div
                        className="legend-color"
                        style={{ background: '#198754' }}
                      ></div>
                      <span>Optimized</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
