<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TSP Visual Solver - Sonar & Moore Curve Algorithms</title>
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
          sans-serif;
        background: #f8f9fa;
        min-height: 100vh;
        color: #212529;
      }

      .app {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px;
        padding: clamp(12px, 3vw, 24px);
      }

      h1 {
        font-size: clamp(1.25rem, 4vw, 1.5rem);
        font-weight: 600;
        margin-bottom: clamp(16px, 3vw, 24px);
        color: #212529;
        text-align: center;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: clamp(8px, 2vw, 16px);
        margin-bottom: clamp(16px, 3vw, 24px);
        padding: clamp(12px, 2vw, 16px);
        background: white;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        justify-content: center;
        align-items: flex-end;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .control-group label {
        font-size: 0.75rem;
        font-weight: 500;
        color: #6c757d;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .control-group input,
      .control-group select {
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        font-size: 0.875rem;
        min-width: 80px;
        max-width: 120px;
      }

      .control-group input:focus,
      .control-group select:focus {
        outline: none;
        border-color: #0d6efd;
        box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.25);
      }

      .buttons {
        display: flex;
        gap: 8px;
        align-items: flex-end;
      }

      button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition:
          background-color 0.2s,
          transform 0.1s;
      }

      button:active {
        transform: scale(0.98);
      }

      .btn-primary {
        background: #0d6efd;
        color: white;
      }

      .btn-primary:hover {
        background: #0b5ed7;
      }

      .btn-primary:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn-secondary:hover {
        background: #5c636a;
      }

      .btn-outline {
        background: white;
        color: #0d6efd;
        border: 1px solid #0d6efd;
      }

      .btn-outline:hover {
        background: #0d6efd;
        color: white;
      }

      .visualization-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(min(100%, 400px), 1fr));
        gap: clamp(16px, 3vw, 24px);
      }

      .visualization {
        background: white;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .visualization-header {
        padding: 12px 16px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .visualization-header h2 {
        font-size: clamp(0.875rem, 2.5vw, 1rem);
        font-weight: 600;
      }

      .visualization-stats {
        font-size: 0.75rem;
        color: #6c757d;
      }

      .canvas-wrapper {
        padding: clamp(8px, 2vw, 16px);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      canvas,
      svg {
        border: 1px solid #dee2e6;
        border-radius: 4px;
        max-width: 100%;
        height: auto;
      }

      .step-info {
        padding: 12px 16px;
        border-top: 1px solid #dee2e6;
        font-size: 0.875rem;
        color: #495057;
        background: #f8f9fa;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: clamp(8px, 2vw, 16px);
        padding: clamp(8px, 2vw, 12px) clamp(12px, 2vw, 16px);
        border-top: 1px solid #dee2e6;
        font-size: clamp(0.65rem, 1.5vw, 0.75rem);
        justify-content: center;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
      }

      .speed-control {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .speed-control input[type='range'] {
        width: 100px;
      }

      .algorithm-aliases {
        padding: 6px 16px;
        font-size: clamp(0.6rem, 1.5vw, 0.7rem);
        color: #868e96;
        background: #f1f3f5;
        font-style: italic;
        text-align: center;
      }

      /* Mobile-first responsive adjustments */
      @media (max-width: 480px) {
        .controls {
          flex-direction: column;
          align-items: stretch;
        }

        .control-group {
          width: 100%;
        }

        .control-group input,
        .control-group select {
          width: 100%;
          max-width: none;
        }

        .buttons {
          width: 100%;
          justify-content: center;
        }

        .speed-control {
          width: 100%;
          justify-content: space-between;
        }

        .speed-control input[type='range'] {
          flex: 1;
          width: auto;
        }

        .visualization-header {
          flex-direction: column;
          gap: 4px;
          text-align: center;
        }
      }

      @media (min-width: 481px) and (max-width: 768px) {
        .controls {
          justify-content: space-around;
        }
      }

      @media (max-width: 768px) {
        .visualization-container {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // Utility functions

      // Calculate the Moore grid size based on user-specified grid size
      // Moore curve of order n fills a 2^(n+1) x 2^(n+1) grid
      // We choose order such that mooreGridSize >= gridSize
      const calculateMooreGridSize = (gridSize) => {
        const order = Math.max(1, Math.min(4, Math.floor(Math.log2(gridSize))));
        return Math.pow(2, order + 1);
      };

      const generateRandomPoints = (mooreGridSize, numPoints) => {
        const points = [];
        const usedPositions = new Set();
        // Points are placed at grid intersections (0 to mooreGridSize inclusive)
        const maxPoints = Math.min(
          numPoints,
          (mooreGridSize + 1) * (mooreGridSize + 1)
        );

        while (points.length < maxPoints) {
          // Generate integer coordinates aligned to Moore grid vertices
          const x = Math.floor(Math.random() * (mooreGridSize + 1));
          const y = Math.floor(Math.random() * (mooreGridSize + 1));
          const key = `${x},${y}`;

          if (!usedPositions.has(key)) {
            usedPositions.add(key);
            points.push({ x, y, id: points.length });
          }
        }
        return points;
      };

      const distance = (p1, p2) => Math.hypot(p2.x - p1.x, p2.y - p1.y);

      const calculateTotalDistance = (tour, points) => {
        if (tour.length < 2) return 0;
        let total = 0;
        for (let i = 0; i < tour.length - 1; i++) {
          total += distance(points[tour[i]], points[tour[i + 1]]);
        }
        // Close the loop
        total += distance(points[tour[tour.length - 1]], points[tour[0]]);
        return total;
      };

      // Sonar Algorithm (Radial Sweep)
      // Starts from the bottom (positive Y direction) and sweeps clockwise
      const sonarAlgorithmSteps = (points) => {
        if (points.length === 0) return [];

        // Find centroid
        const cx = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const cy = points.reduce((sum, p) => sum + p.y, 0) / points.length;

        // Calculate angles from centroid
        // We want to start from the bottom (positive Y direction = Math.PI/2)
        // and sweep clockwise (increasing angle in SVG coordinate system)
        const startAngle = Math.PI / 2; // Bottom direction

        const pointsWithAngles = points.map((p, idx) => {
          const rawAngle = Math.atan2(p.y - cy, p.x - cx);
          // Normalize angle relative to start angle (bottom)
          // This makes angles go from 0 (bottom) clockwise around
          let normalizedAngle = rawAngle - startAngle;
          // Ensure positive values: wrap negative angles to positive
          if (normalizedAngle < 0) {
            normalizedAngle += 2 * Math.PI;
          }
          return {
            ...p,
            idx,
            angle: rawAngle, // Keep original for display
            sortAngle: normalizedAngle, // Use normalized for sorting
          };
        });

        // Sort by normalized angle (starting from bottom, going clockwise)
        pointsWithAngles.sort((a, b) => a.sortAngle - b.sortAngle);

        // Generate steps
        const steps = [];
        const tour = [];

        for (let i = 0; i < pointsWithAngles.length; i++) {
          const currentAngle = pointsWithAngles[i].angle;
          tour.push(pointsWithAngles[i].idx);

          steps.push({
            type: 'sweep',
            angle: currentAngle,
            tour: [...tour],
            description: `Sweep angle: ${(((currentAngle * 180) / Math.PI + 360) % 360).toFixed(1)}°, found point ${pointsWithAngles[i].idx}`,
            centroid: { x: cx, y: cy },
          });
        }

        return steps;
      };

      // Sonar Optimization (2-opt style zigzag)
      const sonarOptimizationSteps = (points, initialTour) => {
        if (initialTour.length < 4) return [];

        const steps = [];
        const tour = [...initialTour];
        let improved = true;
        let iteration = 0;
        const maxIterations = 100;

        while (improved && iteration < maxIterations) {
          improved = false;
          iteration++;

          for (let i = 0; i < tour.length - 2; i++) {
            const p1 = points[tour[i]];
            const p2 = points[tour[i + 1]];
            const p3 = points[tour[(i + 2) % tour.length]];
            const p4 = points[tour[(i + 3) % tour.length]];

            const currentDist = distance(p1, p2) + distance(p3, p4);
            const newDist = distance(p1, p3) + distance(p2, p4);

            if (newDist < currentDist - 0.001) {
              // Swap p2 and p3 positions in tour
              const idx2 = (i + 1) % tour.length;
              const idx3 = (i + 2) % tour.length;
              [tour[idx2], tour[idx3]] = [tour[idx3], tour[idx2]];

              steps.push({
                type: 'optimize',
                tour: [...tour],
                swapped: [tour[idx2], tour[idx3]],
                improvement: currentDist - newDist,
                description: `Zigzag optimization: swapped points, saved ${(currentDist - newDist).toFixed(2)} units`,
              });

              improved = true;
            }
          }
        }

        return steps;
      };

      // Moore Curve Algorithm
      // Moore curve is a variant of Hilbert curve that starts and ends at the same location
      // Generate Hilbert curve points using recursive algorithm for perfect grid alignment
      const hilbertD2xy = (n, d) => {
        // Convert Hilbert curve index d to (x, y) coordinates
        // n is the size of the grid (must be power of 2)
        let x = 0,
          y = 0;
        let rx,
          ry,
          s,
          t = d;

        for (s = 1; s < n; s *= 2) {
          rx = 1 & (t / 2);
          ry = 1 & (t ^ rx);

          // Rotate quadrant
          if (ry === 0) {
            if (rx === 1) {
              x = s - 1 - x;
              y = s - 1 - y;
            }
            [x, y] = [y, x];
          }

          x += s * rx;
          y += s * ry;
          t = Math.floor(t / 4);
        }

        return { x, y };
      };

      const generateMooreCurvePoints = (gridSize) => {
        // For Moore curve, we need a power of 2 grid size
        // Find the largest power of 2 that fits within gridSize
        const order = Math.max(1, Math.floor(Math.log2(gridSize)));
        const curveGridSize = Math.pow(2, order);
        const totalPoints = curveGridSize * curveGridSize;

        // Scale factor to map curve coordinates to actual grid
        const scale = gridSize / curveGridSize;

        // Generate all points along the Hilbert curve
        const points = [];
        for (let i = 0; i < totalPoints; i++) {
          const { x, y } = hilbertD2xy(curveGridSize, i);
          // Map to grid coordinates - center each cell, then scale
          points.push({
            x: (x + 0.5) * scale,
            y: (y + 0.5) * scale,
          });
        }

        // For Moore curve, we need to create a closed loop
        // Moore curve consists of 4 Hilbert curves rotated and connected
        // For simplicity, we'll use a single Hilbert curve which is also space-filling
        return { points, order, curveGridSize };
      };

      // Alternative: Generate Moore curve using L-system for exact Moore pattern
      const generateMooreCurve = (order) => {
        // L-system rules for Moore curve
        // Axiom: LFL+F+LFL
        // L -> -RF+LFL+FR-
        // R -> +LF-RFR-FL+

        let sequence = 'LFL+F+LFL';

        for (let i = 0; i < order; i++) {
          let newSequence = '';
          for (const char of sequence) {
            if (char === 'L') {
              newSequence += '-RF+LFL+FR-';
            } else if (char === 'R') {
              newSequence += '+LF-RFR-FL+';
            } else {
              newSequence += char;
            }
          }
          sequence = newSequence;
        }

        return sequence;
      };

      const mooreCurveToPoints = (sequence, mooreGridSize) => {
        // Moore curve vertices land exactly on grid intersections
        // Step size is 1 (each move goes to the next grid line)
        const stepSize = 1;

        const curvePoints = [];
        // Moore curve starts at the bottom center of the grid
        // For a 16x16 grid (mooreGridSize=16), the curve spans 0 to 16
        // Start at bottom center: x = mooreGridSize/2, y = mooreGridSize (just below visible area)
        // We'll trace the curve first, then normalize to fit within grid
        let x = 0;
        let y = 0;

        // Direction: 0=up, 1=right, 2=down, 3=left
        let direction = 0; // Start facing up

        curvePoints.push({ x, y });

        for (const char of sequence) {
          if (char === 'F') {
            // Move one step in current direction
            if (direction === 0)
              y -= stepSize; // up
            else if (direction === 1)
              x += stepSize; // right
            else if (direction === 2)
              y += stepSize; // down
            else if (direction === 3) x -= stepSize; // left

            curvePoints.push({ x, y });
          } else if (char === '+') {
            direction = (direction + 1) % 4; // Turn right
          } else if (char === '-') {
            direction = (direction + 3) % 4; // Turn left
          }
        }

        // Find bounding box of the curve
        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        for (const p of curvePoints) {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        }

        // The curve naturally spans (curveWidth) x (curveHeight) in step units
        const curveWidth = maxX - minX;
        const curveHeight = maxY - minY;

        // Shift curve so it starts at (0,0), vertices stay on integer grid
        // Then scale to fit the mooreGridSize (vertices land on grid lines)
        const normalizedPoints = curvePoints.map((p) => ({
          x: Math.round(((p.x - minX) / curveWidth) * mooreGridSize),
          y: Math.round(((p.y - minY) / curveHeight) * mooreGridSize),
        }));

        return normalizedPoints;
      };

      const mooreAlgorithmSteps = (points, mooreGridSize) => {
        if (points.length === 0) return [];

        // Determine appropriate Moore curve order based on Moore grid size
        // mooreGridSize = 2^(order+1), so order = log2(mooreGridSize) - 1
        const order = Math.max(1, Math.round(Math.log2(mooreGridSize)) - 1);
        const curveSequence = generateMooreCurve(order);
        // Generate curve points using the Moore grid size for perfect alignment
        const curvePoints = mooreCurveToPoints(curveSequence, mooreGridSize);
        const totalCurveLength = curvePoints.length;

        // Points are already on Moore grid coordinates, no scaling needed
        // Map each point to its position along the curve
        const pointsWithCurvePos = points.map((p, idx) => {
          let minDist = Infinity;
          let curvePos = 0;

          // Points are already in Moore grid coordinates
          for (let i = 0; i < curvePoints.length; i++) {
            const d = distance(p, curvePoints[i]);
            if (d < minDist) {
              minDist = d;
              curvePos = i;
            }
          }

          return { ...p, idx, curvePos };
        });

        // Sort points by their position along the curve
        pointsWithCurvePos.sort((a, b) => a.curvePos - b.curvePos);

        // Generate steps
        const steps = [];
        const tour = [];

        // First step: show the Moore curve
        steps.push({
          type: 'curve',
          curvePoints,
          mooreGridSize,
          curveProgress: 0,
          tour: [],
          description: `Moore curve generated (order ${order}, ${mooreGridSize}×${mooreGridSize} grid)`,
        });

        for (let i = 0; i < pointsWithCurvePos.length; i++) {
          tour.push(pointsWithCurvePos[i].idx);
          // Calculate progress along the curve as a percentage
          const curveProgress = (
            (pointsWithCurvePos[i].curvePos / (totalCurveLength - 1)) *
            100
          ).toFixed(1);

          steps.push({
            type: 'visit',
            curvePoints,
            mooreGridSize,
            curvePosition: pointsWithCurvePos[i].curvePos,
            curveProgress: parseFloat(curveProgress),
            tour: [...tour],
            description: `Curve progress: ${curveProgress}%, visiting point ${pointsWithCurvePos[i].idx}`,
          });
        }

        return steps;
      };

      // Moore Optimization (2-opt)
      const mooreOptimizationSteps = (points, initialTour) => {
        if (initialTour.length < 4) return [];

        const steps = [];
        const tour = [...initialTour];
        let improved = true;
        let iteration = 0;
        const maxIterations = 50;

        while (improved && iteration < maxIterations) {
          improved = false;
          iteration++;

          for (let i = 0; i < tour.length - 1; i++) {
            for (let j = i + 2; j < tour.length; j++) {
              if (i === 0 && j === tour.length - 1) continue;

              const a = points[tour[i]];
              const b = points[tour[i + 1]];
              const c = points[tour[j]];
              const d = points[tour[(j + 1) % tour.length]];

              const currentDist = distance(a, b) + distance(c, d);
              const newDist = distance(a, c) + distance(b, d);

              if (newDist < currentDist - 0.001) {
                // Reverse the segment between i+1 and j
                const segment = tour.slice(i + 1, j + 1).reverse();
                tour.splice(i + 1, j - i, ...segment);

                steps.push({
                  type: 'optimize',
                  tour: [...tour],
                  reversed: [i + 1, j],
                  improvement: currentDist - newDist,
                  description: `2-opt: reversed segment [${i + 1}, ${j}], saved ${(currentDist - newDist).toFixed(2)} units`,
                });

                improved = true;
                break;
              }
            }
            if (improved) break;
          }
        }

        return steps;
      };

      // SVG Renderer Component - replaces Canvas for better quality and scalability
      const TSPVisualization = ({
        points,
        steps,
        currentStep,
        algorithm,
        mooreGridSize,
        showOptimization,
      }) => {
        const containerRef = useRef(null);
        const [svgSize, setSvgSize] = useState(400);
        const padding = 20;

        // Responsive SVG sizing
        useEffect(() => {
          const updateSize = () => {
            if (containerRef.current) {
              const containerWidth = containerRef.current.clientWidth;
              // Max size 400, min size 280, responsive to container
              const newSize = Math.min(400, Math.max(280, containerWidth - 32));
              setSvgSize(newSize);
            }
          };

          updateSize();
          window.addEventListener('resize', updateSize);
          return () => window.removeEventListener('resize', updateSize);
        }, []);

        const size = svgSize;

        // Get current step data
        const step =
          currentStep >= 0 && currentStep < steps.length
            ? steps[currentStep]
            : null;

        // Both algorithms use the same Moore grid size for perfect alignment
        const displayGridSize = mooreGridSize;

        const scale = (size - 2 * padding) / displayGridSize;

        // Convert coordinates to SVG space
        // All points and curve vertices are in Moore grid coordinates
        const toSvgCoords = (p) => {
          return {
            x: padding + p.x * scale,
            y: padding + p.y * scale,
          };
        };

        // Generate grid lines
        const gridLines = [];
        for (let i = 0; i <= displayGridSize; i++) {
          const pos = padding + i * scale;
          gridLines.push(
            <line
              key={`v-${i}`}
              x1={pos}
              y1={padding}
              x2={pos}
              y2={size - padding}
              stroke="#e9ecef"
              strokeWidth="1"
            />
          );
          gridLines.push(
            <line
              key={`h-${i}`}
              x1={padding}
              y1={pos}
              x2={size - padding}
              y2={pos}
              stroke="#e9ecef"
              strokeWidth="1"
            />
          );
        }

        // Generate Moore curve path - progressive animation
        // Draw visited portion in green, remaining portion in gray
        let mooreCurvePath = null;
        let mooreCurveGrayPath = null;
        if (
          algorithm === 'moore' &&
          step?.curvePoints &&
          step.curvePoints.length > 0
        ) {
          // Determine the curve position up to which we've progressed
          const curvePosition = step.curvePosition !== undefined ? step.curvePosition : 0;

          // Split curve into visited (green) and unvisited (gray) portions
          const visitedPoints = step.curvePoints.slice(0, curvePosition + 1);
          const unvisitedPoints = step.curvePoints.slice(curvePosition);

          // Draw the unvisited (gray) portion first (so green appears on top)
          if (unvisitedPoints.length > 1) {
            const grayPathData = unvisitedPoints
              .map((p, i) => {
                const coords = toSvgCoords(p);
                return i === 0
                  ? `M ${coords.x} ${coords.y}`
                  : `L ${coords.x} ${coords.y}`;
              })
              .join(' ');
            mooreCurveGrayPath = (
              <path
                d={grayPathData}
                fill="none"
                stroke="rgba(156, 163, 175, 0.5)"
                strokeWidth="3"
                strokeLinecap="square"
                strokeLinejoin="miter"
              />
            );
          }

          // Draw the visited (green) portion
          if (visitedPoints.length > 0) {
            const greenPathData = visitedPoints
              .map((p, i) => {
                const coords = toSvgCoords(p);
                return i === 0
                  ? `M ${coords.x} ${coords.y}`
                  : `L ${coords.x} ${coords.y}`;
              })
              .join(' ');
            mooreCurvePath = (
              <path
                d={greenPathData}
                fill="none"
                stroke="rgba(34, 197, 94, 0.6)"
                strokeWidth="3"
                strokeLinecap="square"
                strokeLinejoin="miter"
              />
            );
          }
        }

        // Generate sweep line for Sonar
        let sweepLine = null;
        let centroidCircle = null;
        if (algorithm === 'sonar' && step?.type === 'sweep' && step?.centroid) {
          const center = toSvgCoords(step.centroid);
          const lineLength = size;
          sweepLine = (
            <line
              x1={center.x}
              y1={center.y}
              x2={center.x + lineLength * Math.cos(step.angle)}
              y2={center.y + lineLength * Math.sin(step.angle)}
              stroke="rgba(13, 110, 253, 0.3)"
              strokeWidth="2"
            />
          );
          centroidCircle = (
            <circle cx={center.x} cy={center.y} r="4" fill="#0d6efd" />
          );
        }

        // Generate tour path
        let tourPath = null;
        if (step?.tour && step.tour.length > 1) {
          const isOptimization = step.type === 'optimize' || showOptimization;
          const tourPoints = step.tour.map((idx) => toSvgCoords(points[idx]));
          let pathData = tourPoints
            .map((p, i) => (i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`))
            .join(' ');
          // Close the loop if tour is complete
          if (step.tour.length === points.length) {
            pathData += ' Z';
          }
          tourPath = (
            <path
              d={pathData}
              fill="none"
              stroke={isOptimization ? '#198754' : '#0d6efd'}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          );
        }

        // Generate point circles
        const pointCircles = points.map((point, idx) => {
          const p = toSvgCoords(point);
          const isInTour = step?.tour?.includes(idx);
          const isLastAdded =
            step?.tour && step.tour[step.tour.length - 1] === idx;

          let fill = '#6c757d';
          if (isLastAdded) {
            fill = '#dc3545';
          } else if (isInTour) {
            fill = '#0d6efd';
          }

          return (
            <circle
              key={`point-${idx}`}
              cx={p.x}
              cy={p.y}
              r={isLastAdded ? 6 : 4}
              fill={fill}
            />
          );
        });

        return (
          <div
            ref={containerRef}
            style={{ width: '100%', display: 'flex', justifyContent: 'center' }}
          >
            <svg
              width={size}
              height={size}
              viewBox={`0 0 ${size} ${size}`}
              style={{
                border: '1px solid #dee2e6',
                borderRadius: '4px',
                background: '#ffffff',
              }}
            >
              {/* Grid lines */}
              <g>{gridLines}</g>
              {/* Moore curve - gray (unvisited) portion first, then green (visited) on top */}
              {mooreCurveGrayPath}
              {mooreCurvePath}
              {/* Sweep line for Sonar */}
              {sweepLine}
              {centroidCircle}
              {/* Tour path */}
              {tourPath}
              {/* Points */}
              <g>{pointCircles}</g>
            </svg>
          </div>
        );
      };

      // Keep TSPCanvas as alias for backward compatibility
      const TSPCanvas = TSPVisualization;

      // Main App Component
      const App = () => {
        const [gridSize, setGridSize] = useState(10);
        const [numPoints, setNumPoints] = useState(15);
        const [points, setPoints] = useState([]);
        const [speed, setSpeed] = useState(500);
        const [isRunning, setIsRunning] = useState(false);
        const [showOptimization, setShowOptimization] = useState(false);

        // Calculate Moore grid size - this is the unified grid both algorithms use
        // This ensures points land on grid vertices and both algorithms use identical grids
        const mooreGridSize = calculateMooreGridSize(gridSize);

        // Sonar state
        const [sonarSteps, setSonarSteps] = useState([]);
        const [sonarOptSteps, setSonarOptSteps] = useState([]);
        const [sonarCurrentStep, setSonarCurrentStep] = useState(-1);

        // Moore state
        const [mooreSteps, setMooreSteps] = useState([]);
        const [mooreOptSteps, setMooreOptSteps] = useState([]);
        const [mooreCurrentStep, setMooreCurrentStep] = useState(-1);

        const animationRef = useRef(null);

        const generatePoints = useCallback(() => {
          // Generate points on the Moore grid - both algorithms use the same grid
          const newPoints = generateRandomPoints(mooreGridSize, numPoints);
          setPoints(newPoints);
          setSonarSteps([]);
          setSonarOptSteps([]);
          setSonarCurrentStep(-1);
          setMooreSteps([]);
          setMooreOptSteps([]);
          setMooreCurrentStep(-1);
          setIsRunning(false);
          setShowOptimization(false);
        }, [mooreGridSize, numPoints]);

        useEffect(() => {
          generatePoints();
        }, []);

        const startSolution = useCallback(() => {
          if (points.length === 0) return;

          // Generate steps for both algorithms using the same Moore grid
          const newSonarSteps = sonarAlgorithmSteps(points);
          const newMooreSteps = mooreAlgorithmSteps(points, mooreGridSize);

          setSonarSteps(newSonarSteps);
          setMooreSteps(newMooreSteps);
          setSonarCurrentStep(0);
          setMooreCurrentStep(0);
          setShowOptimization(false);
          setIsRunning(true);
        }, [points, mooreGridSize]);

        const stopAnimation = useCallback(() => {
          setIsRunning(false);
          if (animationRef.current) {
            clearTimeout(animationRef.current);
          }
        }, []);

        const startOptimization = useCallback(() => {
          if (sonarSteps.length === 0 || mooreSteps.length === 0) return;

          const sonarTour = sonarSteps[sonarSteps.length - 1]?.tour || [];
          const mooreTour = mooreSteps[mooreSteps.length - 1]?.tour || [];

          const newSonarOptSteps = sonarOptimizationSteps(points, sonarTour);
          const newMooreOptSteps = mooreOptimizationSteps(points, mooreTour);

          setSonarOptSteps(newSonarOptSteps);
          setMooreOptSteps(newMooreOptSteps);
          setSonarCurrentStep(0);
          setMooreCurrentStep(0);
          setShowOptimization(true);
          setIsRunning(true);
        }, [points, sonarSteps, mooreSteps]);

        // Animation loop
        useEffect(() => {
          if (!isRunning) return;

          const currentSonarSteps = showOptimization
            ? sonarOptSteps
            : sonarSteps;
          const currentMooreSteps = showOptimization
            ? mooreOptSteps
            : mooreSteps;

          const sonarDone = sonarCurrentStep >= currentSonarSteps.length - 1;
          const mooreDone = mooreCurrentStep >= currentMooreSteps.length - 1;

          if (sonarDone && mooreDone) {
            setIsRunning(false);
            return;
          }

          animationRef.current = setTimeout(() => {
            if (!sonarDone) {
              setSonarCurrentStep((prev) =>
                Math.min(prev + 1, currentSonarSteps.length - 1)
              );
            }
            if (!mooreDone) {
              setMooreCurrentStep((prev) =>
                Math.min(prev + 1, currentMooreSteps.length - 1)
              );
            }
          }, speed);

          return () => {
            if (animationRef.current) {
              clearTimeout(animationRef.current);
            }
          };
        }, [
          isRunning,
          sonarCurrentStep,
          mooreCurrentStep,
          speed,
          showOptimization,
          sonarSteps,
          mooreSteps,
          sonarOptSteps,
          mooreOptSteps,
        ]);

        const getSonarStep = () => {
          const steps = showOptimization ? sonarOptSteps : sonarSteps;
          return steps[sonarCurrentStep];
        };

        const getMooreStep = () => {
          const steps = showOptimization ? mooreOptSteps : mooreSteps;
          return steps[mooreCurrentStep];
        };

        const calculateSonarDistance = () => {
          const step = getSonarStep();
          if (!step?.tour || step.tour.length < 2) return 0;
          return calculateTotalDistance(step.tour, points);
        };

        const calculateMooreDistance = () => {
          const step = getMooreStep();
          if (!step?.tour || step.tour.length < 2) return 0;
          return calculateTotalDistance(step.tour, points);
        };

        const canOptimize =
          sonarSteps.length > 0 &&
          mooreSteps.length > 0 &&
          !isRunning &&
          !showOptimization &&
          sonarCurrentStep === sonarSteps.length - 1;

        return (
          <div className="app">
            <h1>TSP Visual Solver</h1>

            <div className="controls">
              <div className="control-group">
                <label>Grid Size (N)</label>
                <input
                  type="number"
                  min="5"
                  max="50"
                  value={gridSize}
                  onChange={(e) =>
                    setGridSize(
                      Math.max(5, Math.min(50, parseInt(e.target.value) || 5))
                    )
                  }
                  disabled={isRunning}
                />
              </div>

              <div className="control-group">
                <label>Points (M)</label>
                <input
                  type="number"
                  min="3"
                  max={(mooreGridSize + 1) * (mooreGridSize + 1)}
                  value={numPoints}
                  onChange={(e) =>
                    setNumPoints(Math.max(3, parseInt(e.target.value) || 3))
                  }
                  disabled={isRunning}
                />
              </div>

              <div className="control-group">
                <label>Animation Speed</label>
                <div className="speed-control">
                  <span>Fast</span>
                  <input
                    type="range"
                    min="50"
                    max="1000"
                    value={speed}
                    onChange={(e) => setSpeed(parseInt(e.target.value))}
                  />
                  <span>Slow</span>
                </div>
              </div>

              <div className="buttons">
                <button
                  className="btn-outline"
                  onClick={generatePoints}
                  disabled={isRunning}
                >
                  New Points
                </button>

                {!isRunning ? (
                  <>
                    <button
                      className="btn-primary"
                      onClick={startSolution}
                      disabled={points.length === 0}
                    >
                      Start
                    </button>

                    {canOptimize && (
                      <button
                        className="btn-secondary"
                        onClick={startOptimization}
                      >
                        Optimize
                      </button>
                    )}
                  </>
                ) : (
                  <button className="btn-secondary" onClick={stopAnimation}>
                    Stop
                  </button>
                )}
              </div>
            </div>

            <div className="visualization-container">
              <div className="visualization">
                <div className="visualization-header">
                  <h2>Sonar Visit Algorithm</h2>
                  <span className="visualization-stats">
                    Distance: {calculateSonarDistance().toFixed(2)}
                  </span>
                </div>
                <div className="algorithm-aliases">
                  Also known as: Radial Sweep, Angular Sort, Polar Angle Sort,
                  Centroid-based Ordering
                </div>
                <div className="canvas-wrapper">
                  <TSPCanvas
                    points={points}
                    steps={showOptimization ? sonarOptSteps : sonarSteps}
                    currentStep={sonarCurrentStep}
                    algorithm="sonar"
                    mooreGridSize={mooreGridSize}
                    showOptimization={showOptimization}
                  />
                </div>
                <div className="step-info">
                  {getSonarStep()?.description || 'Click Start to begin'}
                </div>
                <div className="legend">
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#6c757d' }}
                    ></div>
                    <span>Unvisited</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#0d6efd' }}
                    ></div>
                    <span>In Tour</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#dc3545' }}
                    ></div>
                    <span>Current</span>
                  </div>
                  {showOptimization && (
                    <div className="legend-item">
                      <div
                        className="legend-color"
                        style={{ background: '#198754' }}
                      ></div>
                      <span>Optimized</span>
                    </div>
                  )}
                </div>
              </div>

              <div className="visualization">
                <div className="visualization-header">
                  <h2>Moore Curve Algorithm</h2>
                  <span className="visualization-stats">
                    Distance: {calculateMooreDistance().toFixed(2)}
                  </span>
                </div>
                <div className="algorithm-aliases">
                  Also known as: Space-Filling Curve, Hilbert Curve Variant,
                  Fractal Ordering
                </div>
                <div className="canvas-wrapper">
                  <TSPCanvas
                    points={points}
                    steps={showOptimization ? mooreOptSteps : mooreSteps}
                    currentStep={mooreCurrentStep}
                    algorithm="moore"
                    mooreGridSize={mooreGridSize}
                    showOptimization={showOptimization}
                  />
                </div>
                <div className="step-info">
                  {getMooreStep()?.description || 'Click Start to begin'}
                </div>
                <div className="legend">
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: 'rgba(34, 197, 94, 0.6)' }}
                    ></div>
                    <span>Visited Curve</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: 'rgba(156, 163, 175, 0.5)' }}
                    ></div>
                    <span>Unvisited Curve</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#0d6efd' }}
                    ></div>
                    <span>Tour Path</span>
                  </div>
                  <div className="legend-item">
                    <div
                      className="legend-color"
                      style={{ background: '#dc3545' }}
                    ></div>
                    <span>Current</span>
                  </div>
                  {showOptimization && (
                    <div className="legend-item">
                      <div
                        className="legend-color"
                        style={{ background: '#198754' }}
                      ></div>
                      <span>Optimized</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
